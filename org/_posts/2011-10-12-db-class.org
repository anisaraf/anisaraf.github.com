#+TITLE:     2011-10-12-ai-class.org
#+AUTHOR:    Anirudh Saraf
#+EMAIL:     anirudhsaraf@gmail.com
#+DATE:      2011-10-13 Thu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:3 \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:t toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

#+BEGIN_HTML
---
layout: post
title: Personal notes for the stanford db-class
tags: ai, stanford, lecture notes
---
#+END_HTML

I am following the Stanford [[http://www.db-class.com][db-class]] online, and using this post for
keeping track of progress/notes/links etc. These notes are very rough,
mostly a personal log of progress...

* Homework Notes
* Lecture Notes
** Lecture 1: Intro to databases
   + Massive data; Persistent; Safe; Multi-user; Convenient; Convenient
      (Physical data layout independence; SQL - declarative); Efficient; Reliable


  
   + Data Model - set of records; XML; graph 
    Schema vs Data ( types/ variables)
    DDL - Data Definition Language - set up schema
    DML - Data manipulation (querying / modification)
** Lecture 2: Relational Model
   + Be careful of Null values! GPA > 3.5 or GPA <= 3.5 ( doesn't return null values)

** Lecture 2 : Query Relational Databases
   + Relational Algebra - formal (theory) ; SQL (actual/ implementation)

** XML Data
   + Tree hierarchy; XSLT (XML -> HTML) ; 
   + DTD
   + XSD - Like DTD, data types, typed pointers, checked
     types(e.g. integers) etc.
     + XSD written in XML 

** Relational Algebra
   + \sigma _{condition} (Expression) [select rows]
   + Relational Algebra based on sets = removes duplicates (contrary
     to SQL - multisets)
   + Cross-product combine two relations
   + Natural Join - filtered crossproduct on common attributes and eliminates
     the duplicate attribute.
   + theta join \sigma_{\theta} (Expr1 <natural join> Expr2) [ joins
     in sql]
   + Union [Vertical]
   + Difference
   + Intersection [ doesn't add expressive power]
   + Rename operator \rho disambiguation in self-joins

** SQL
   + Union: select cName as name from College union select sName as
     name from Student; (union eliminates duplicates)
   + union all : retains duplicates
   + intersect : students whos applied to both CS and EE
     select xx where major = 'EE' intersect select ... where major = 'CS'
   + except : applied to CS but not EE (difference operator)
     + select ... where CS except select ... where EE
   + Subqueries in where clause
     - Select sName from student where sId in (select sId from Apply
       where major = 'CS') equivalent to
     - Select DISTINCT sName from Student,Apply where student.id =
       apply.id and major = 'CS'
     - DISTINCT is needed to eliminate students who applied to
       multiple CS programs from showing up multiple times
     - Replicate except with where in / not in
     - Exists
     - all (whether value has a relationship with all elements in the subquery)
       - select sName, GPA from Student where GPA >= all (select GPA
         from Student); [student with highest GPA]
     - any [ satisfy with any one element in the set]

   + Aggregation
     - min, max, sum, avg, count
     - Group by - allows to partition relation into groups and compute
       aggregate over each group
     - Having - applies to groups generated by group by clause
     - eg. select avg(GPA) from Student;
     - Running averages
       - select avg(GPA) from Student,Apply where student.sID =
         apply.sID and major = 'CS'
       - Has a problem where if a student applies to multiple colleges
         then he appears multiple times
       - FIX: select avg(gpa) from student where sID in (select sID from
         Apply where major='CS'); (doesn't have multiple copies!)
       - Write a subquery in select clause as long as it returns a
         single value
       - GROUP BY only used with aggregate functions; returns 1 row
         for each group!
       - Group by can have multiple cols: Group by cName, major
       - Having is used in conjuction with aggregation; applied after
         the group by clause and applies conditions to entire group!
       - Every query written by Group by and Having can be written
         without them!
** Null Values 
   + undefined/unknown values
   + select sID, sName, GPA from Student where GPA > 3.5 or GPA <= 3.5 or GPA is null;
   + Null values are not picked up by mathematical constructs! We need
     the GPA is null to pick up null values
   + count(distinct GPA) doesn't pick up null values!
   + select distinct GPA from Student does pick up the null!
   + Be careful of unexpected behaviors about nulls

** Modifications

   + Insert Into Table values (A_1, ... A_n)
   + Insert Into Table select values (insert's from another table)
   + Delete from Table where Condition
   + Update Table Set Attr=Expression WHERE Condition
   + You can't specify target table 'Apply' for update in FROM clause;
     Some systems allow you to select from the table you are
     deleting(Postgres) while some systems don't allow it!
   + Way around it is to create a temporary table and then use that to
     delete things.
     - create temporary table a1 select sID from Apply group by sID having count(distinct major) > 2;
     - delete from Apply where sID in (select sID from a1);

** Relation Design Theory

*** Overview
    + How to design schemas
    + Design 'anomalies'
      - Redundancy (how many times do we capture a tuple)
      - Update anomaly (you can update facts differently in different places)
      - Deletion anomaly (inadvertently delete someone in the database)
    + Design by decomposition
      - Start with mega relations
      - Decompose into smaller, better relations
      - Can do decomposition automatically by specifying properties
    + Properties and Normal Forms
      - Functional dependencies -> Boyce-Codd Normal Form
      - Multivalued dependencies -> fourth normal form (Stricter)
    + Example: Apply(SSN, sName, cName)
      - Redundancy, UPdate and delete anamolies (SSN-sName pair)
      - Functional Dependency SSN -> sName
	- Same SSN always has same sName
	- Should store this info only once
      - BCNF if A -> B then A is a key!
      - Decompose Student(SSN,sName), Apply(SSN,cName); it's a key!
      - Multivalued Dependencies and 4NF
	- Apply(SSN, cName, HS)
	- Multiplicative effect for HS (C * H tuples)
	- No functional dependencies, so BCNF not addressed
	- Multivalued dependency SSN ->> cName (implies SSN ->> HS)
	  - Given SSN has every combination of cName with HS
	  - Should store each cName and each HS for an SSN once
	- 4NF: If A ->> B then A is a key
	- Decompose: Apply (SSN, cName) HighSchool (SSN, HS) [C + H tuples]
	  
*** Functional dependencies
    + Useful for compression/ reasoning about queries / generalization
      of keys
    + A -> B (if a values are same then b values are also same)
    + Implies A is key, so we can't have two rows with same A and B
    + Splitting Rule
      + A -> B1, B2 etc.. then A -> B1, A -> B2
      + Applies only to RHS not LHS
    + Combining Rule (combine RHS)
    + A -> B then A -> A \intersection B ; A -> A \union B
    + Transitive rule is valid
    + Closure of attributes - determines all attributes functionally
      determined by the LHS for which we are seeking closure; Add rhs's to the lhs and continue till
      nothing left to add
    + Closure of attributes allows you to find keys!
    + Compute cloure of A and if = all attributes then A is a key
    + To find all keys consider every subset in increasing size order
      till we have a complete closure
    + Does S2 follow from S1
      + Compute closure A based on S ; check if B in Set or
      + Armstrong's axioms
    + Eventuall we want the minimal set of completely non-trivial FDs
      such that all FDs follow from the dependencies in this set!
*** Boyce-Codd Normal Form
    + 

*** MVD & 4NF
    + Separation of indenpendant facts
    + 

** Triggers and constraints
   + not null; primary key etc.
   + Can only have one 'primary key'; can have cmpound primary key -
     which is different from multiple primary keys.
   + null doesn't count as unique - you can get multiple values for
     unique constraint; bu usually not for primary keys
   + check constraint - pretty cool but doesn't work in MySql
   + check assertion - not implemented in mySql
   + 
   + 
*** Referential Ingtegrit
    + from R.A to S.B
    + A is called the foreign key
    + B is usually required to be unique/primary
    + Multi-attribut is allowed.
    + Violating modifications
      - Insert into R
      - Delete from S
      - Update R.A/S.B
    + If Insert into R/Update R.A -> if violation then error
    + If Deltete/Update from S then special actions possible!
      + Restrict, Set Null, Cascade

*** Triggers
    + Move monitoring into RDMS
    + Has repar logic
    + Create Trigger name Before|After|Instead of events (insert,
      delte update of cols on T) [For Each Row?] <- run it once for
      each affected row or once?
    + old row as ; new row as ; old table as ; new table as
      (referencing variables) Row level trigger will trigger after
      each affected row, table level at table level.
    + Tricky issues:
      + Row level va Statement level
      + Multiple triggers at the same time
      + Chained,cycles, self-triggering, nested triggers
      + Conditions in when vs. as part of action
      + Implementations vary significantly
      + Non-deterministic final states!

* Web Links
  + [[http://www.reddit.com/r/dbclass][Reddit Discussions]]

* Other

