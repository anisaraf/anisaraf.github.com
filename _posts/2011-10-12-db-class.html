<div id="outline-container-1" class="outline-3">
<h3 id="sec-1">Null Values </h3>
<div class="outline-text-3" id="text-1">

<ul>
<li>undefined/unknown values
</li>
<li>select sID, sName, GPA from Student where GPA &gt; 3.5 or GPA &lt;= 3.5 or GPA is null;
</li>
<li>Null values are not picked up by mathematical constructs! We need
     the GPA is null to pick up null values
</li>
<li>count(distinct GPA) doesn't pick up null values!
</li>
<li>select distinct GPA from Student does pick up the null!
</li>
<li>Be careful of unexpected behaviors about nulls
</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">Modifications </h3>
<div class="outline-text-3" id="text-2">


<ul>
<li>Insert Into Table values (A<sub>1</sub>, &hellip; A<sub>n</sub>)
</li>
<li>Insert Into Table select values (insert's from another table)
</li>
<li>Delete from Table where Condition
</li>
<li>Update Table Set Attr=Expression WHERE Condition
</li>
<li>You can't specify target table 'Apply' for update in FROM clause;
     Some systems allow you to select from the table you are
     deleting(Postgres) while some systems don't allow it!
</li>
<li>Way around it is to create a temporary table and then use that to
     delete things.
<ul>
<li>create temporary table a1 select sID from Apply group by sID having count(distinct major) &gt; 2;
</li>
<li>delete from Apply where sID in (select sID from a1);
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3">Relation Design Theory </h3>
<div class="outline-text-3" id="text-3">



</div>

<div id="outline-container-3-1" class="outline-4">
<h4 id="sec-3-1">Overview </h4>
<div class="outline-text-4" id="text-3-1">

<ul>
<li>How to design schemas
</li>
<li>Design 'anomalies'
<ul>
<li>Redundancy (how many times do we capture a tuple)
</li>
<li>Update anomaly (you can update facts differently in different places)
</li>
<li>Deletion anomaly (inadvertently delete someone in the database)
</li>
</ul>

</li>
<li>Design by decomposition
<ul>
<li>Start with mega relations
</li>
<li>Decompose into smaller, better relations
</li>
<li>Can do decomposition automatically by specifying properties
</li>
</ul>

</li>
<li>Properties and Normal Forms
<ul>
<li>Functional dependencies -&gt; Boyce-Codd Normal Form
</li>
<li>Multivalued dependencies -&gt; fourth normal form (Stricter)
</li>
</ul>

</li>
<li>Example: Apply(SSN, sName, cName)
<ul>
<li>Redundancy, UPdate and delete anamolies (SSN-sName pair)
</li>
<li>Functional Dependency SSN -&gt; sName
<ul>
<li>Same SSN always has same sName
</li>
<li>Should store this info only once
</li>
</ul>

</li>
<li>BCNF if A -&gt; B then A is a key!
</li>
<li>Decompose Student(SSN,sName), Apply(SSN,cName); it's a key!
</li>
<li>Multivalued Dependencies and 4NF
<ul>
<li>Apply(SSN, cName, HS)
</li>
<li>Multiplicative effect for HS (C * H tuples)
</li>
<li>No functional dependencies, so BCNF not addressed
</li>
<li>Multivalued dependency SSN -&gt;&gt; cName (implies SSN -&gt;&gt; HS)
<ul>
<li>Given SSN has every combination of cName with HS
</li>
<li>Should store each cName and each HS for an SSN once
</li>
</ul>

</li>
<li>4NF: If A -&gt;&gt; B then A is a key
</li>
<li>Decompose: Apply (SSN, cName) HighSchool (SSN, HS) [C + H tuples]
</li>
</ul>

</li>
</ul>

</li>
</ul>

</div>
</div>
</div>
