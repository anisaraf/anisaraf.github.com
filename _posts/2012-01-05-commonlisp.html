---
layout: post
title: Personal notes - common lisp
tags: ai, stanford, lecture notes
---

<p>
As a die-hard emacs fan (this blog runs out of emacs! - with a little
help from github), I quickly realized that to gain the most out of my
editor I needed to stop hacking on lisp and take a structured approach
to learning it. Keeping this post to keep track of some common/emacs
lisp notes as I learn about the language! 
</p>
<p>
I am using this <a href="http://www.gigamonkeys.com/book/">free book</a> to learn!
</p>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Notes </h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">List: </h3>
<div class="outline-text-3" id="text-1-1">

<ul>
<li>'(a b c d)
</li>
<li>'(this list has (a list inside of it))
</li>
<li>'() empty list
</li>
<li>Text between double quotation marks&ndash;even sentences or
     paragraphs&ndash;is also an atom.  Here is an example: 
    '(this list includes "text between quotation marks.")
</li>
</ul>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">set/setq </h3>
<div class="outline-text-3" id="text-1-2">

<ul>
<li>(setq trees '(pine fir oak maple)
           herbivores '(gazelle antelope zebra))
</li>
<li>setq can be used to set multiple values
</li>
<li>automatically quotes the first argument etc.
</li>
<li>Counter
     (setq counter 0)                ; Let's call this the initializer.
     (setq counter (+ counter 1))    ; This is the incrementer.
     counter                         ; This is the counter.
</li>
</ul>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Buffer functions </h3>
<div class="outline-text-3" id="text-1-3">

<ul>
<li>(buffer-name); (buffer-file-name); (current-buffer); (other-buffer)
</li>
<li>(point) (point-min) (point-max)
</li>
<li>(with-current-buffer) (set-buffer)
</li>
</ul>


</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Functions </h3>
<div class="outline-text-3" id="text-1-4">

<ul>
<li>(defun FUNCTION-NAME (ARGUMENTS&hellip;)
</li>
</ul>

<p>  "OPTIONAL-DOCUMENTATION&hellip;"
  (interactive ARGUMENT-PASSING-INFO)     ; optional
  BODY&hellip;)
</p><ul>
<li>(defun multiply-by-seven (number)
</li>
</ul>

<p>  "Multiply NUMBER by seven."
  (* 7 number))
</p>
<ul>
<li>Interactive functions don't display the return value after
     evaluation.Called mainly for their side-effects
</li>
<li>`(interactive "p")', is a list of
</li>
</ul>

<p>  two elements.  The `"p"' tells Emacs to pass the prefix argument to the
  function and use its value for the argument of the function.
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Special Forms </h3>
<div class="outline-text-3" id="text-1-5">

<ul>
<li>defun
</li>
<li>let - local variables; default value of nil
</li>
<li>let* binds the values sequentially so you can refer to earlier variables
</li>
<li>if 
     (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE
       ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-FALSE)
</li>
<li>save-excursion; returns point and mark and current-buffer to the state they were in
     before execution of the function
</li>
<li>An `or' function can have any number of arguments.  It evaluates
</li>
</ul>

<p>each argument in turn and returns the value of the first of its
arguments that is not `nil'.  Also, and this is a crucial feature of
`or', it does not evaluate any subsequent arguments after returning the
first non-`nil' value.
</p>

</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">List functions </h3>
<div class="outline-text-3" id="text-1-6">


<ul>
<li>car: first element of the list; non-destructive
</li>
<li>cdr: rest of the list
</li>
<li>(cons 'pine '(fir oak maple)) ; creates a new list - non-destructive
</li>
<li>(lenght ()) -&gt; length of the list
</li>
<li>(nthcdr 1 '(pint fir oak maple)) -&gt; (fir oak maple)
</li>
<li>(nth 1 '()) -&gt; returns nth element of the list
</li>
<li>(setcar animals 'hippopotamus) -&gt; changes the list by setting the first element
</li>
<li>(setcdr animals '()) -&gt; changes the rest of the list
</li>
</ul>



</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">Random Info </h3>
<div class="outline-text-3" id="text-1-7">


<ul>
<li>nil, (), false
</li>
<li>C-u C-x C-e 
     (message "insert his text here")"insert his text here"
</li>
<li>(search-forward)
</li>
</ul>




</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">progn </h3>
<div class="outline-text-3" id="text-1-8">

<ul>
<li>(progn
       BODY&hellip;) : returns the value from the last evaluated expression
     throwing away intermediate return values.
</li>
</ul>




</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Common Lisp: </h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">Compiling </h3>
<div class="outline-text-3" id="text-2-1">

<ul>
<li>Use C-c C-c in slime to install defun
</li>
<li>Use C-c C-k to compile and load file 
     (load (compile-file "hello.cl"))
</li>
</ul>

</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">Chapter 2: </h3>
<div class="outline-text-3" id="text-2-2">

<ul>
<li>(list :a 1 :b 2 :c 3)
</li>
<li>(getf (list) :a)
</li>
<li>
</li>
</ul>


</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">Chapter 4: functions </h3>
<div class="outline-text-3" id="text-2-3">

<ul>
<li>required params
</li>
<li>optional params (a b &amp;optional c d)
<ul>
<li>default values: &amp;optional (c 10) (d 20)
</li>
<li>can refer to earlier arguments as well so (c a) c = a if not supplied!
</li>
<li>check if default value (c 10 c-supplied-p)
</li>
</ul>

</li>
<li>variable params: (&hellip;. &amp;rest values) -&gt; values = list of params
</li>
<li>Keyword params - (&amp;key a b c) -&gt; after required, optiona and rest
     params. Like optional params, but not positional
</li>
<li>(function name) ; gets function object #'name
</li>
</ul>


</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4">Collections </h3>
<div class="outline-text-3" id="text-2-4">


<ul>
<li>(make-array 5 :fill-pointer 0 :adjustable t) ==&gt; #()
</li>
<li>VECTOR-PUSH-EXTEND
</li>
<li>(make-array 5 :fill-pointer 0 :adjustable t :element-type
     'character)  "" resizable string!
</li>
<li>has a BIT vector as well
</li>
<li>(length x) (elt x 3)
</li>
<li>(setf (elt <b>x</b> 0) 10) set value!
</li>
<li>Functions for operating on sequences
     Name       Requirned Arguments           Returns
     COUNT      Item and sequence            Number of times item appears in sequence
     FIND       Item and sequence            Item or NIL
     POSITION   Item and sequence            Index into sequence or NIL
     REMOVE     Item and sequence            Sequence with instances of item removed
     SUBSTITUTE New item, item, and sequence Sequence with instances
     of item replaced with new item
     (count 1 #(1 2 1 2 3 1 2 3 4))         ==&gt; 3
      (remove 1 #(1 2 1 2 3 1 2 3 4))        ==&gt; #(2 2 3 2 3 4)
      (remove 1 '(1 2 1 2 3 1 2 3 4))        ==&gt; (2 2 3 2 3 4)
      (remove #\a "foobarbaz")               ==&gt; "foobrbz"
      (substitute 10 1 #(1 2 1 2 3 1 2 3 4)) ==&gt; #(10 2 10 2 3 10 2 3 4)
      (substitute 10 1 '(1 2 1 2 3 1 2 3 4)) ==&gt; (10 2 10 2 3 10 2 3 4)
      (substitute #\x #\b "foobarbaz")       ==&gt; "fooxarxaz"
      (find 1 #(1 2 1 2 3 1 2 3 4))          ==&gt; 1
      (find 10 #(1 2 1 2 3 1 2 3 4))         ==&gt; NIL
      (position 1 #(1 2 1 2 3 1 2 3 4))      ==&gt; 0
</li>
<li>Named arguments for functions 
     Argument  Meaning                                                                                                               Default
        :test     Two-argument function used to compare item (or value extracted by :key function) to element.                          EQL
        :key      One-argument function to extract key value from actual sequence element. NIL means use element as is.                 NIL
        :start    Starting index (inclusive) of subsequence.                                                                            0
        :end      Ending index (exclusive) of subsequence. NIL indicates end of sequence.                                               NIL
        :from-end If true, the sequence will be traversed in reverse order, from end to start.                                          NIL
        :count    Number indicating the number of elements to remove or substitute or NIL to indicate all (REMOVE and SUBSTITUTE only). NIL
</li>
<li>Append -if and -if-not ; takes a function instead of item
</li>
<li>(remove-duplicates #(1 2 3 1)) =&gt; (1 2 3)
</li>
<li>copy-seq, reverse, concatenate
     (concatenate 'list #(1 2 3) '(4 5 6))      ==&gt; (1 2 3 4 5 6)
</li>
<li>(sort (vector "foo" "bar" "baz") #'string&lt;) ==&gt; #("bar" "baz" "foo")
     stable-sort
     (setf my-sequence (sort my-sequence #'string&lt;))
</li>
<li>(merge 'vector #(1 3 5) #(2 4 6) #'&lt;) ==&gt; #(1 2 3 4 5 6)
</li>
<li>(setf (subseq <b>x</b> 3 6) "xx")   ; new value too short, only two characters changed
     <b>x</b> ==&gt; "fooxxcbaz"
</li>
<li>fill seq value :start :end
</li>
<li>position, search, mismatch
</li>
<li>EVERY, SOME, NOTANY, NOTEVERY
</li>
<li>MAP, MAP-INTO, REDUCE
</li>
<li>GETHASH, REMHASH, CLRHASH, MAPHASH
</li>
<li>(maphash #'(lambda (k v) (format t "~a =&gt; ~a~%" k v)) <b>h</b>)
</li>
</ul>

</div>
</div>
</div>
